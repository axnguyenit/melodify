import 'dart:math';

import 'package:flutter/foundation.dart';

class Log {
  static final Log _singleton = Log._internal();

  static const topLeftCorner = '╔'; // ┌
  static const topRightCorner = '╗'; // ┐
  static const bottomLeftCorner = '╚'; // └
  static const bottomRightCorner = '╝'; // ┘
  static const midLeftCorner = '╠'; // ├
  static const midRightCorner = '╣'; // ┤
  static const verticalLine = '║'; // │
  static const line = '═'; // ─
  static const maxLength = 100;
  static const initialTab = 0;
  static const compact = false;
  static const chunkSize = 20;

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #0      Log._log (package:core/log/log.dart:86:37)
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((^\s+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// dart-sdk/lib/_internal/js_dev_runtime/patch/core_patch.dart 963:28
  /// ../dart-sdk/lib/_internal/js_dev_runtime/patch/core_patch.dart 963:28
  static final _webStackTraceRegex = RegExp(r'^([[.]+\/]?)?dart-sdk\/[^\s]+\/');

  /// ANSI Control Sequence Introducer, signals the terminal for new settings.
  static const ansiEsc = '\x1B[';

  /// Reset all colors and options for current SGRs to terminal defaults.
  static const ansiDefault = '${ansiEsc}0m';

  factory Log() {
    return _singleton;
  }

  Log._internal();

  // log for debug - not in production, only for debug purpose
  void debug(dynamic message, {List<String> messages = const []}) {
    _log(message, messages);
  }

  // log for event, actions, ...
  void info(dynamic message, {List<String> messages = const []}) {
    _log(message, messages, 12);
  }

  // log for tracking - not in production, should remove all
  void trace(dynamic message, {List<String> messages = const []}) {
    _log(message, messages, 232 + (0.5.clamp(0.0, 1.0) * 23).round());
  }

  // log for unexpected value or data, potential lead to bug
  void warning(dynamic message, {List<String> messages = const []}) {
    _log(message, messages, 208);
  }

  // log for try/catch
  void error(dynamic message, {List<String> messages = const []}) {
    _log(message, messages, 196);
  }

  // app crash, freeze, ...
  void fatal(dynamic message, {List<String> messages = const []}) {
    _log(message, messages, 199);
  }

  bool _discardDeviceStacktraceLine(String line) {
    if (line.startsWith('packages/core/log/log')) return true;

    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) return false;

    return match.group(1)!.startsWith(runtimeType.toString());
  }

  void _log(dynamic message, [List<String> messages = const [], int? fg]) {
    if (kReleaseMode) return;
    final lineLine = StringBuffer();
    final singleDividerLine = StringBuffer();

    for (int i = 0; i < maxLength - 2; i++) {
      lineLine.write(line);
      singleDividerLine.write(line);
    }

    final topBorder = '$topLeftCorner$lineLine$topRightCorner';
    final midBorder = '$midLeftCorner$singleDividerLine$midRightCorner';
    final bottomBorder = '$bottomLeftCorner$lineLine$bottomRightCorner';
    List<String> lines = StackTrace.current.toString().split('\n');
    lines = lines.sublist(2);

    _logWithColor(topBorder, fg);

    for (int i = 0; i < lines.length; i++) {
      if (_discardDeviceStacktraceLine(lines[i]) ||
          _webStackTraceRegex.hasMatch(lines[i]) ||
          lines[i].isEmpty) continue;

      final fileName = lines[i]
          .replaceFirst(RegExp(r'#\d+\s+'), '')
          .split('/')
          .last
          .split(')')
          .first;
      _logWithColor('$verticalLine $fileName', fg);
      _logWithColor('$verticalLine ${DateTime.now()}', fg);

      break;
    }

    _logWithColor(midBorder, fg);
    _logWithColor('$verticalLine $message', fg);
    for (final message in messages) {
      _logWithColor('$verticalLine $message', fg);
    }
    _logWithColor(bottomBorder, fg);
  }

  void _logWithColor(dynamic message, [int? fg]) {
    if (fg == null) return debugPrint(message);

    debugPrint('${ansiEsc}38;5;${fg}m$message$ansiDefault');
  }

  // ────────────────────────────────────────────
  String _indent([int tabCount = initialTab]) => '  ' * tabCount;

  bool _canFlattenMap(Map map) {
    return map.values
            .where((dynamic val) => val is Map || val is List)
            .isEmpty &&
        map.toString().length < maxLength;
  }

  bool _canFlattenList(List list) {
    return list.length < 10 && list.toString().length < maxLength;
  }

  void topDivider() {
    printLine(
      topLeftCorner,
      topRightCorner,
    );
  }

  void bottomDivider() {
    printLine(
      bottomLeftCorner,
      bottomRightCorner,
    );
  }

  void printLine([String pre = '', String suf = bottomRightCorner]) =>
      _logWithColor('$pre${line * maxLength}$suf', 12);

  void logMap(
    Map data, {
    int initialTab = initialTab,
    bool isListItem = false,
    bool isLast = false,
  }) {
    var tabs = initialTab;
    final isRoot = tabs == initialTab;
    final initialIndent = _indent(tabs);
    tabs++;

    if (isRoot || isListItem) _logWithColor('$verticalLine$initialIndent{', 12);

    data.keys.toList().asMap().forEach((index, dynamic key) {
      final isLast = index == data.length - 1;
      dynamic value = data[key];
      if (value is String) {
        value = '"${value.toString().replaceAll(RegExp(r'([\r\n])+'), " ")}"';
      }
      if (value is Map) {
        if (compact && _canFlattenMap(value)) {
          _logWithColor(
              '$verticalLine${_indent(tabs)}$key: $value${!isLast ? ',' : ''}',
              12);
        } else {
          _logWithColor('$verticalLine${_indent(tabs)}$key: {', 12);
          logMap(value, initialTab: tabs);
        }
      } else if (value is List) {
        if (compact && _canFlattenList(value)) {
          _logWithColor(
              '$verticalLine${_indent(tabs)}$key: ${value.toString()}', 12);
        } else {
          _logWithColor('$verticalLine${_indent(tabs)}$key:', 12);
          logList(value, tabs: tabs, isLast: isLast);
        }
      } else {
        final msg = value.toString().replaceAll('\n', '');
        _logWithColor(
            '$verticalLine${_indent(tabs)}$key: $msg${!isLast ? ',' : ''}', 12);
      }
    });

    _logWithColor(
        '$verticalLine$initialIndent}${isListItem && !isLast ? ',' : ''}', 12);
  }

  void logUint8List(Uint8List list, {int tabs = initialTab}) {
    final chunks = [];
    for (var i = 0; i < list.length; i += chunkSize) {
      chunks.add(
        list.sublist(
            i, i + chunkSize > list.length ? list.length : i + chunkSize),
      );
    }
    _logWithColor('$verticalLine${_indent()}[', 12);
    for (final element in chunks) {
      _logWithColor('$verticalLine${_indent(tabs)} ${element.join(", ")}', 12);
    }
    _logWithColor('$verticalLine${_indent()}]', 12);
  }

  void logList(List list, {int tabs = initialTab, bool isLast = true}) {
    _logWithColor('$verticalLine${_indent(tabs)}[', 12);
    list.asMap().forEach((i, dynamic e) {
      final isLast = i == list.length - 1;
      if (e is Map) {
        if (compact && _canFlattenMap(e)) {
          _logWithColor(
              '$verticalLine${_indent(tabs)}$e${!isLast ? ',' : ''}', 12);
        } else {
          logMap(
            e,
            initialTab: tabs + 1,
            isListItem: true,
            isLast: isLast,
          );
        }
      } else {
        _logWithColor(
            '$verticalLine${_indent(tabs + 1)}$e${isLast ? '' : ','}', 12);
      }
    });
    _logWithColor('$verticalLine${_indent(tabs)}]${isLast ? '' : ','}', 12);
  }

  void logBox({required String header, String? text}) {
    _logWithColor('');
    _logWithColor(
        '''$topLeftCorner$midRightCorner $header $midLeftCorner${line * (maxLength - 4 - header.length)}$topRightCorner''',
        12);
    _logWithColor('$verticalLine  $text', 12);
    printLine(bottomLeftCorner);
  }

  void _printKV(String key, Object? v) {
    final pre = '$midLeftCorner $key: ';
    final msg = v.toString();

    if (pre.length + msg.length > maxLength) {
      _logWithColor(pre, 12);
      logBlock(msg);
    } else {
      _logWithColor('$pre$msg', 12);
    }
  }

  void logBlock(String msg) {
    final lines = (msg.length / maxLength).ceil();
    for (var i = 0; i < lines; ++i) {
      _logWithColor(
          (i >= 0 ? '$verticalLine ' : '') +
              msg.substring(
                i * maxLength,
                min<int>(
                  i * maxLength + maxLength,
                  msg.length,
                ),
              ),
          12);
    }
  }

  void logMapAsTable(Map? map, {required String header}) {
    if (map == null || map.isEmpty) return;
    _logWithColor(
        '''$topLeftCorner$midRightCorner $header $midLeftCorner${line * (maxLength - 4 - header.length)}$topRightCorner''',
        12);
    map.forEach(
      (dynamic key, dynamic value) => _printKV(
        key.toString(),
        value,
      ),
    );
    printLine(bottomLeftCorner);
  }
}
